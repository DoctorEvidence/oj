// Generated by CoffeeScript 1.7.1

/*
OJ IIFE definition to anchor JsDoc comments.
 */

(function() {
  var NsTree, makeTheJuice, nameSpaceName, thisDocument, thisGlobal, utilLib;

  thisGlobal = (typeof global !== 'undefined' && global ? global : typeof window !== 'undefined' ? window : this);

  utilLib = thisGlobal.jQuery;

  nameSpaceName = 'OJ';


  /*
  boot strap name method into Object prototype
   */

  Object.defineProperties(Object.prototype, {
    getInstanceName: {
      value: function() {
        var funcNameRegex, results;
        funcNameRegex = /function (.{1,})\(/;
        results = funcNameRegex.exec(this.constructor.toString());
        if (results && results.length > 1) {
          return results[1];
        } else {
          return '';
        }
      }
    }
  });


  /*
  An internal representation of the namespace tree
   */

  NsTree = {};

  makeTheJuice = function() {

    /*
    Internal nameSpaceName method to create new 'sub' namespaces on arbitrary child objects.
     */
    var NsOut, dependsOn, makeNameSpace, nsInternal;
    makeNameSpace = function(spacename, tree) {

      /*
      The derived instance to be constructed
       */
      var Base, Class;
      Base = function(nsName) {
        var members, nsTree, proto;
        proto = this;
        tree[nsName] = tree[nsName] || {};
        nsTree = tree[nsName];
        members = {};
        Object.defineProperty(this, 'members', {
          value: members
        });

        /*
        Register (e.g. 'Lift') an Object into the prototype of the namespace.
        This Object will be readable/executable but is otherwise immutable.
         */
        Object.defineProperty(this, 'register', {
          value: function(name, obj, enumerable) {
            'use strict';
            if ((typeof name !== 'string') || name === '') {
              throw new Error('Cannot lift a new property without a valid name.');
            }
            if (!obj) {
              throw new Error('Cannot lift a new property without a valid property instance.');
            }
            if (proto[name]) {
              throw new Error('Property named ' + name + ' is already defined on ' + spacename + '.');
            }
            members[name] = members[name] || name;
            nsTree[name] = nsTree[name] || {
              name: name,
              type: typeof obj,
              instance: (obj.getInstanceName ? obj.getInstanceName() : 'unknown')
            };
            Object.defineProperty(proto, name, {
              value: obj,
              enumerable: false !== enumerable
            });
            nsInternal.alertDependents(nsName + '.' + spacename + '.' + name);
            return obj;
          }
        });

        /*
        Create a new, static namespace on the current parent (e.g. nsName.to... || nsName.is...)
         */
        proto.register('makeSubNameSpace', (function(subNameSpace) {
          'use strict';
          var newNameSpace;
          if ((typeof subNameSpace !== 'string') || subNameSpace === '') {
            throw new Error('Cannot create a new sub namespace without a valid name.');
          }
          if (proto.subNameSpace) {
            throw new Error('Sub namespace named ' + subNameSpace + ' is already defined on ' + spacename + '.');
          }
          nsInternal.alertDependents(nsName + '.' + subNameSpace);
          newNameSpace = makeNameSpace(subNameSpace, nsTree);
          if (subNameSpace !== 'constants') {
            newNameSpace.register('constants', makeNameSpace('constants', nsTree), false);
          }
          proto.register(subNameSpace, newNameSpace, false);
          return newNameSpace;
        }), false);
      };

      /*
      An internal mechanism to represent the instance of this namespace
      @constructor
      @internal
      @memberOf makeNameSpace
       */
      Class = new Function('return function ' + spacename + '(){}')();
      Class.prototype = new Base(spacename);
      return new Class(spacename);
    };

    /*
    'Depend' an Object upon another member of this namespace, upon another namespace,
    or upon a member of another namespace
     */
    dependsOn = function(dependencies, callBack, imports) {
      'use strict';
      var missing, nsMembers, ret;
      ret = false;
      nsMembers = nsInternal.getNsMembers();
      if (dependencies && dependencies.length > 0 && callBack) {
        missing = dependencies.filter(function(depen) {
          return nsMembers.indexOf(depen) === -1 && (!imports || imports !== depen);
        });
        if (missing.length === 0) {
          ret = true;
          callBack();
        } else {
          nsInternal.dependents.push(function(imports) {
            return dependsOn(missing, callBack, imports);
          });
        }
      }
      return ret;
    };
    nsInternal = {
      dependents: []
    };

    /*
    Fetches the registered properties and methods on the namespace and its child namespaces
     */
    Object.defineProperty(nsInternal, 'getNsMembers', {
      value: function() {
        var members, recurseTree;
        recurseTree = function(key, lastKey) {
          if (typeof key === 'string') {
            members.push(lastKey + '.' + key);
          }
          if (utilLib.isPlainObject(key)) {
            Object.keys(key).forEach(function(k) {
              if (typeof k === 'string') {
                members.push(lastKey + '.' + k);
              }
              if (utilLib.isPlainObject(key[k])) {
                recurseTree(key[k], lastKey + '.' + k);
              }
            });
          }
        };
        members = [];
        Object.keys(NsTree[nameSpaceName]).forEach(function(key) {
          if (utilLib.isPlainObject(NsTree[nameSpaceName][key])) {
            recurseTree(NsTree[nameSpaceName][key], nameSpaceName);
          }
        });
        return members;
      }
    });

    /*
    To support dependency management, when a property is lifted onto the namespace, notify dependents to initialize
     */
    Object.defineProperty(nsInternal, 'alertDependents', {
      value: function(imports) {
        var deps;
        deps = nsInternal.dependents.filter(function(depOn) {
          return false === depOn(imports);
        });
        if (Array.isArray(deps)) {
          nsInternal.dependents = deps;
        }
      }
    });
    NsTree[nameSpaceName] = {};
    NsOut = makeNameSpace(nameSpaceName, NsTree[nameSpaceName]);

    /*
    Cache a handle on the vendor (probably jQuery) on the root namespace
     */
    NsOut.register('?', utilLib, false);

    /*
    Cache the tree (useful for documentation/visualization/debugging)
     */
    NsOut.register('tree', NsTree[nameSpaceName], false);

    /*
    Cache the name space name
     */
    NsOut.register('name', nameSpaceName, false);
    NsOut.register('dependsOn', dependsOn, false);
    return NsOut;
  };


  /*
  Actually define the OJ NameSpace
   */

  Object.defineProperty(thisGlobal, nameSpaceName, {
    value: makeTheJuice()
  });

  OJ.register('global', thisGlobal);

  thisDocument = {};

  if (typeof document !== 'undefined') {
    thisDocument = document;
  }

  OJ.register('document', thisDocument);

  OJ.register('noop', function() {});

}).call(this);

//# sourceMappingURL=oj.js.map