// Generated by CoffeeScript 1.7.1
(function() {
  var __slice = [].slice;

  (function(OJ) {
    var rangeToSubRanges, stringRangeToSubRanges;
    OJ.register('range', function() {
      var params;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _.range.apply(_, params);
    });
    OJ.register('rangeMin', function() {
      var params;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _.min.apply(_, params);
    });
    OJ.register('rangeMax', function() {
      var params;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _.max.apply(_, params);
    });

    /*
    Take an array of string values and a number of partitions to create.
    Uses the first letter of each string value in the array to convert to unique code character (lower case)
    Builds a int range based on unique code chars.
     */
    stringRangeToSubRanges = function(n, range) {
      var charRange, i, oldGetRange, ret, subRange;
      if (n == null) {
        n = 6;
      }
      if (range == null) {
        range = [];
      }
      charRange = [];
      OJ.each(range, function(val) {
        var char;
        char = val.trim()[0].toLowerCase();
        if (false === OJ.contains(charRange, char)) {
          return charRange.push(char.charCodeAt());
        }
      });
      ret = rangeToSubRanges(n, charRange);
      i = 0;
      while (i < n) {
        i += 1;
        subRange = ret[i];
        subRange.map(String.fromCharCode);
      }
      oldGetRange = ret.getRange;
      ret.getRange = function(val) {
        var char, idx;
        char = val.trim()[0].toLowerCase().charCodeAt();
        idx = oldGetRange(char);
        return idx;
      };
      return ret;
    };

    /*
    Take an array of int values and a number of partitions to create.
    Divides the original array into the specified number of sub arrays.
    Overflow is passed to the final partition.
     */
    rangeToSubRanges = function(n, range) {
      var chunkVal, distance, i, jump, map, rangeHigh, rangeLow, ret, subRange, subRangeSize, subRanges;
      if (n == null) {
        n = 6;
      }
      if (range == null) {
        range = [];
      }
      ret = OJ.object();
      rangeLow = OJ.rangeMin(range);
      rangeHigh = OJ.rangeMax(range);
      distance = rangeHigh - rangeLow;
      subRangeSize = distance / n;
      subRanges = ret.add('ranges', OJ.object());
      chunkVal = rangeLow;
      map = OJ.object();
      i = 0;
      while (i < n) {
        i += 1;
        if (i < n) {
          jump = Math.round(subRangeSize);
        } else {
          jump = Math.floor(subRangeSize);
          if (chunkVal + jump <= rangeHigh) {
            jump += rangeHigh - chunkVal - jump + 1;
          }
        }
        subRange = OJ.range(chunkVal, chunkVal + jump);
        OJ.each(subRange, function(val) {
          return map.add(val, i);
        });
        subRanges[i] = subRange;
        chunkVal += jump;
      }
      ret.add('getRange', function(val) {
        return map[val];
      });
      return ret;
    };
    OJ.register('stringRangeToSubRanges', stringRangeToSubRanges);
    OJ.register('rangeToSubRanges', rangeToSubRanges);
  })((typeof global !== 'undefined' && global ? global : (typeof window !== 'undefined' ? window : this)).OJ);

}).call(this);

//# sourceMappingURL=ranges.js.map