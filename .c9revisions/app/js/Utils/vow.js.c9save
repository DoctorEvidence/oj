{"ts":1359428638174,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// vow.js\r\n// Douglas Crockford\r\n// 2013-01-28\r\n\r\n// Public Domain\r\n\r\n/*global setImmediate */\r\n\r\n\r\nvar VOW = (function () {\r\n    'use strict';\r\n\r\n// The VOW object contains a .make function that is used to make vows.\r\n// It may also contain other useful functions.\r\n// In some mythologies, 'VOW' is called 'deferrer'.\r\n\r\n    function enlighten(queue, fate) {\r\n\r\n// enlighten is a helper function of herald and .when. It schedules the\r\n// processing of all of the resolution functions in either the keepers queue\r\n// or the breakers queue in later turns with the promise's fate.\r\n\r\n        queue.forEach(function (func) {\r\n            setImmediate(func, fate);\r\n        });\r\n    }\r\n\r\n    return {\r\n        make: function make() {\r\n\r\n// The make function makes new vows. A vow contains a promise object and the\r\n// two resolution functions (break and keep) that determine the fate of the\r\n// promise.\r\n\r\n            var breakers = [],          // .when's broken queue\r\n                fate,                   // The promise's ultimate value\r\n                keepers = [],           // .when's kept queue\r\n                status = 'pending';     // 'broken', 'kept', or 'pending'\r\n\r\n            function enqueue(\r\n                resolution, // 'keep' or 'break'\r\n                func,       // A function that was registered with .when\r\n                vow         // A vow that provides the resolution functions\r\n            ) {\r\n\r\n// enqueue is a helper function used by .when. It will append a function to\r\n// either the keepers queue or the breakers queue.\r\n\r\n                var queue = resolution === 'keep' ? keepers : breakers;\r\n                queue[queue.length] = typeof func !== 'function'\r\n\r\n// If func is not a function, push the resolver so that the value passes to\r\n// the next cascaded .when.\r\n\r\n                    ? vow[resolution]\r\n\r\n// If the func is a function, push a function that calls func with a value.\r\n// The result can be a promise, or not a promise, or an exception.\r\n\r\n                    : function (value) {\r\n                        try {\r\n                            var result = func(value);\r\n\r\n// If the result is a promise, then register our resolver with that promise.\r\n\r\n                            if (result && result.is_promise === true) {\r\n                                result.when(vow.keep, vow['break']);\r\n\r\n// But if it is not a promise, then use the result to resolve our promise.\r\n\r\n                            } else {\r\n                                vow.keep(result);\r\n                            }\r\n\r\n// But if func throws an exception, then break our promise.\r\n\r\n                        } catch (e) {\r\n                            vow['break'](e);\r\n                        }\r\n                    };\r\n            }\r\n\r\n            function herald(state, value, queue) {\r\n\r\n// The herald function is a helper function of break and keep.\r\n// It seals the promise's fate, updates its status, enlightens\r\n// one of the queues, and empties both queues.\r\n\r\n                if (status !== 'pending') {\r\n                    throw \"overpromise\";\r\n                }\r\n                fate = value;\r\n                status = state;\r\n                enlighten(queue, fate);\r\n                keepers.length = 0;\r\n                breakers.length = 0;\r\n            }\r\n\r\n// Construct and return the vow object.\r\n\r\n            return {\r\n                'break': function (value) {\r\n\r\n// The break method breaks the promise. Programs targeted for obsolete ES3\r\n// engines (which at this date is only IE<9) must write vow.break() as\r\n// vow['break']().\r\n\r\n                    herald('broken', value, breakers);\r\n                },\r\n                keep: function keep(value) {\r\n\r\n// The keep method keeps the promise.\r\n\r\n                    herald('kept', value, keepers);\r\n                },\r\n                promise: {\r\n\r\n// The promise is an object with a .when method.\r\n\r\n                    is_promise: true,\r\n\r\n// The .when method is the promise monad's bind. The .when method can take two\r\n// optional functions. One of those functions may be called, depending on the\r\n// promise's resolution. Both could be called if the the kept function throws.\r\n\r\n                    when: function (kept, broken) {\r\n\r\n// Make a new vow. Return the new promise.\r\n\r\n                        var vow = make();\r\n                        switch (status) {\r\n\r\n// If this promise is still pending, then enqueue both kept and broken.\r\n\r\n                        case 'pending':\r\n                            enqueue('keep',  kept,   vow);\r\n                            enqueue('break', broken, vow);\r\n                            break;\r\n\r\n// If the promise has already been kept, then enqueue only the kept function,\r\n// and enlighten it.\r\n\r\n                        case 'kept':\r\n                            enqueue('keep', kept, vow);\r\n                            enlighten(keepers, fate);\r\n                            break;\r\n\r\n// If the promise has already been broken, then enqueue only the broken\r\n// function, and enlighten it.\r\n\r\n                        case 'broken':\r\n                            enqueue('break', broken, vow);\r\n                            enlighten(breakers, fate);\r\n                            break;\r\n                        }\r\n                        return vow.promise;\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        every: function every(array) {\r\n\r\n// The every function takes an array of promises and returns a promise that\r\n// will deliver an array of results only if every promise is kept.\r\n\r\n            var remaining = array.length, results = [], vow = VOW.make();\r\n\r\n            if (!remaining) {\r\n                vow['break'](array);\r\n            } else {\r\n                array.forEach(function (promise, i) {\r\n                    promise.when(function (value) {\r\n                        results[i] = value;\r\n                        remaining -= 1;\r\n                        if (remaining === 0) {\r\n                            vow.keep(results);\r\n                        }\r\n                    }, function (reason) {\r\n                        remaining = NaN;\r\n                        vow['break'](reason);\r\n                    });\r\n                });\r\n            }\r\n            return vow.promise;\r\n        },\r\n        first: function first(array) {\r\n\r\n// The first function takes an array of promises and returns a promise to\r\n// deliver the first observed kept promise, or a broken promise if all of\r\n// the promises are broken.\r\n\r\n            var found = false, remaining = array.length, vow = VOW.make();\r\n\r\n            function check() {\r\n                remaining -= 1;\r\n                if (remaining === 0 && !found) {\r\n                    vow['break']();\r\n                }\r\n            }\r\n\r\n            if (remaining === 0) {\r\n                vow['break'](array);\r\n            } else {\r\n                array.forEach(function (promise) {\r\n                    promise.when(function (value) {\r\n                        if (!found) {\r\n                            found = true;\r\n                            vow.keep(value);\r\n                        }\r\n                        check();\r\n                    }, check);\r\n                });\r\n            }\r\n            return vow.promise;\r\n        },\r\n        any: function any(array) {\r\n\r\n// The any function takes an array of promises and returns a promise that\r\n// will deliver a possibly sparse array of results of any kept promises.\r\n// The result will contain an undefined element for each broken promise.\r\n\r\n            var remaining = array.length, results = [], vow = VOW.make();\r\n\r\n            function check() {\r\n                remaining -= 1;\r\n                if (remaining === 0) {\r\n                    vow.keep(results);\r\n                }\r\n            }\r\n\r\n            if (!remaining) {\r\n                vow.keep(results);\r\n            } else {\r\n                array.forEach(function (promise, i) {\r\n                    promise.when(function (value) {\r\n                        results[i] = value;\r\n                        check();\r\n                    }, check);\r\n                });\r\n            }\r\n            return vow.promise;\r\n        },\r\n        kept: function (value) {\r\n\r\n// Returns a new kept promise.\r\n\r\n            var vow = VOW.make();\r\n            vow.keep(value);\r\n            return vow.promise;\r\n        },\r\n        broken: function (reason) {\r\n\r\n// Returns a new broken promise.\r\n\r\n            var vow = VOW.make();\r\n            vow['break'](reason);\r\n            return vow.promise;\r\n        }\r\n    };\r\n}());\r\n\r\n\r\n// If your system does not have setImmediate, then simulate it with setTimeout.\r\n\r\n// if (typeof setImmediate !== 'function') {\r\n//     setImmediate = function setImmediate(func, param) {\r\n//         'use strict';\r\n//         return setTimeout(function () {\r\n//             func(param);\r\n//         }, 0);\r\n//     };\r\n// }\r\n\r\n\r\n"]],"start1":0,"start2":0,"length1":0,"length2":8916}]],"length":8916}
